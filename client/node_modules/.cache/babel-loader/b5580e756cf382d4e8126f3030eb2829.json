{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\anton\\\\Desktop\\\\FInt.Tchat\\\\dev\\\\V10\\\\client\\\\src\\\\contexts\\\\ChannelsProvider.js\";\nimport React, { useContext, useState, useEffect, useRef } from 'react';\nimport { useSocket } from './SocketProvider';\nimport api from \"../api\";\nconst ChannelsContext = React.createContext();\nexport function useChannels() {\n  return useContext(ChannelsContext);\n}\nexport function ChannelsProvider({\n  id,\n  children\n}) {\n  const socket = useSocket(); // https://stackoverflow.com/questions/54824036/useeffect-hook-with-socket-io-state-is-not-persistent-in-socket-handlers\n\n  const [channels, setChannels] = useState(null);\n  const channelsRef = useRef(channels);\n  useEffect(() => {\n    channelsRef.current = channels;\n  });\n  const [messagesChannels, setMessagesChannels] = useState([]);\n  const messagesChannelsRef = useRef(messagesChannels);\n  useEffect(() => {\n    messagesChannelsRef.current = messagesChannels;\n  });\n  const [selectedChannel, setSelectedChannel] = useState(null);\n  useEffect(() => {\n    if (socket == null) return;\n\n    const addMessage = message => {\n      // J'isole les \"channels\" dans une variable\n      var allMessages = messagesChannelsRef.current; // Récuépration de l'index\n\n      const indexMessage = allMessages.findIndex(messagesChannel => messagesChannel.id === message.channelId);\n\n      if (indexMessage !== -1) {\n        // Copie de l'ancien tableau de données\n        let newArr = [...messagesChannelsRef.current]; // Ajout du nouveau message\n\n        newArr[indexMessage].messages = [...newArr[indexMessage].messages, {\n          sender: message.sender,\n          date: message.date,\n          text: message.text\n        }]; // Envoie des données dans le \"useState\"\n\n        setMessagesChannels(newArr);\n      } else {\n        // Ajout du message dans le \"useState\"\n        setMessagesChannels(msg => [...msg, {\n          id: message.channelId,\n          messages: [{\n            sender: message.sender,\n            date: message.date,\n            text: message.text\n          }]\n        }]);\n      }\n    }; // Si je reçoi un message je l'ajoute dans le \"channel\" qui lui correspond\n\n\n    socket.on('receive-message', addMessage);\n    return () => socket.off('receive-message', addMessage);\n  }, [socket]);\n\n  function addMessageToDatabase(channel, text, client) {\n    // Récupération des données du \"channel\" avec son id\n    api.getChannelById(channel.id).then(channel => {\n      channel = channel.data.data;\n      console.log(channel);\n      channel.messages.push({\n        index: channel.messages.length + 1,\n        sender: client.id,\n        date: new Date(),\n        text: text\n      });\n      api.updateChannelById(channel.id, {\n        data: {\n          messages: channel.messages\n        }\n      }).then(res => {});\n    }, error => {\n      console.log(error);\n    });\n  }\n\n  function sendMessage(channel, text, client, recipients) {\n    socket.emit('send-message', {\n      channelId: channel.id,\n      recipients,\n      date: new Date(),\n      text\n    });\n    addMessageToDatabase(channel, text, client);\n  } // Cette fonction renvoie les données du client\n\n\n  function formattedChannel() {\n    return new Promise(resolve => {\n      // Récupération des données du \"channel\" avec son id\n      api.getChannelById(selectedChannel.id).then(channel => {\n        resolve(selectedChannel);\n      }, error => {\n        console.log(error);\n      });\n    });\n  }\n\n  function createChannel(payload) {\n    api.insertChannel(payload);\n  }\n\n  const value = {\n    channels,\n    setChannels,\n    messagesChannels,\n    setMessagesChannels,\n    selectedChannel,\n    setSelectedChannel,\n    createChannel,\n    formattedChannel,\n    sendMessage\n  };\n  return /*#__PURE__*/React.createElement(ChannelsContext.Provider, {\n    value: value,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 123,\n      columnNumber: 5\n    }\n  }, children);\n}\nexport default ChannelsContext;\n/*\n conversations.map((conversation, index) => {\n   const recipients = conversation.recipients.map(recipient => {\n     const contact = contacts.find(contact => {\n       return contact.id === recipient\n     })\n     const name = (contact && contact.name) || recipient\n     return { id: recipient, name }\n   })\n    const messages = conversation.messages.map(message => {\n     const contact = contacts.find(contact => {\n       return contact.id === message.sender\n     })\n     const name = (contact && contact.name) || message.sender\n     const fromMe = id === message.sender\n     return { ...message, senderName: name, fromMe }\n   })\n    const selected = index === selectedConversationIndex\n   return { ...conversation, messages, recipients, selected }\n })*/\n\n/*\n\nfunction arrayEquality(a, b) {\n  if (a.length !== b.length) return false\n\n  a.sort()\n  b.sort()\n\n  return a.every((element, index) => {\n    return element === b[index]\n  })\n}\n\nconst addMessageToChannel = useCallback(({ recipients, text, sender }) => {\n  setChannels(prevChannels => {\n    let madeChange = false\n    const newMessage = { sender, text }\n    const newChannels = prevChannels.map(channel => {\n      if (arrayEquality(channel.recipients, recipients)) {\n        madeChange = true\n        return {\n          ...channel,\n          messages: [...channel.messages, newMessage]\n        }\n      }\n\n      return channel\n    })\n\n    if (madeChange) {\n      return newChannels\n    } else {\n      return [\n        ...prevChannels,\n        { recipients, messages: [newMessage] }\n      ]\n    }\n  })\n}, [])*/\n\n/*\nconst addMessage = (message) => {\n  // J'isole les \"channels\" dans une variable\n  var allMessages = messagesChannelsRef.current\n\n  const indexMessage = allMessages.findIndex(messagesChannel => messagesChannel.id === message.channelId);\n  console.log(allMessages)\n  if (indexMessage !== -1) {\n    console.log(\"1\")\n    const oldMsg = allMessages[indexMessage].messages\n    setMessagesChannels(msg => [\n      ...msg.slice(0, indexMessage),\n      ...msg.slice(indexMessage + 1)\n    ]);\n    setMessagesChannels(msg => [...msg, { id: message.channelId, messages: [...oldMsg, {sender: message.sender, date: message.date, text: message.text}] }])\n  } else {\n    console.log(\"2\")\n    setMessagesChannels(msg => [...msg, { id: message.channelId, messages: [{sender: message.sender, date: message.date, text: message.text}] }])\n  }\n}*/","map":{"version":3,"sources":["C:/Users/anton/Desktop/FInt.Tchat/dev/V10/client/src/contexts/ChannelsProvider.js"],"names":["React","useContext","useState","useEffect","useRef","useSocket","api","ChannelsContext","createContext","useChannels","ChannelsProvider","id","children","socket","channels","setChannels","channelsRef","current","messagesChannels","setMessagesChannels","messagesChannelsRef","selectedChannel","setSelectedChannel","addMessage","message","allMessages","indexMessage","findIndex","messagesChannel","channelId","newArr","messages","sender","date","text","msg","on","off","addMessageToDatabase","channel","client","getChannelById","then","data","console","log","push","index","length","Date","updateChannelById","res","error","sendMessage","recipients","emit","formattedChannel","Promise","resolve","createChannel","payload","insertChannel","value"],"mappings":"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","sourcesContent":["import React, { useContext, useState, useEffect, useRef } from 'react'\nimport { useSocket } from './SocketProvider';\nimport api from \"../api\"\n\nconst ChannelsContext = React.createContext()\n\nexport function useChannels() {\n  return useContext(ChannelsContext)\n}\n\nexport function ChannelsProvider({ id, children }) {\n  const socket = useSocket()\n  // https://stackoverflow.com/questions/54824036/useeffect-hook-with-socket-io-state-is-not-persistent-in-socket-handlers\n  const [channels, setChannels] = useState(null)\n  const channelsRef = useRef(channels);\n  useEffect(() => {\n    channelsRef.current = channels;\n  });\n\n  const [messagesChannels, setMessagesChannels] = useState([])\n  const messagesChannelsRef = useRef(messagesChannels);\n  useEffect(() => {\n    messagesChannelsRef.current = messagesChannels;\n  });\n\n  const [selectedChannel, setSelectedChannel] = useState(null)\n\n  useEffect(() => {\n    if (socket == null) return\n\n    const addMessage = (message) => {\n      // J'isole les \"channels\" dans une variable\n      var allMessages = messagesChannelsRef.current\n\n      // Récuépration de l'index\n      const indexMessage = allMessages.findIndex(messagesChannel => messagesChannel.id === message.channelId);\n\n      if (indexMessage !== -1) {\n        // Copie de l'ancien tableau de données\n        let newArr = [...messagesChannelsRef.current];\n        // Ajout du nouveau message\n        newArr[indexMessage].messages = [...newArr[indexMessage].messages, {sender: message.sender, date: message.date, text: message.text}];\n        // Envoie des données dans le \"useState\"\n        setMessagesChannels(newArr);\n      } else {\n        // Ajout du message dans le \"useState\"\n        setMessagesChannels(msg => [...msg, { id: message.channelId, messages: [{sender: message.sender, date: message.date, text: message.text}] }])\n      }\n    }\n\n    // Si je reçoi un message je l'ajoute dans le \"channel\" qui lui correspond\n    socket.on('receive-message', addMessage);\n\n    return () => socket.off('receive-message', addMessage)\n  }, [socket])\n\n  function addMessageToDatabase(channel, text, client) {\n\n    // Récupération des données du \"channel\" avec son id\n    api.getChannelById(channel.id).then(\n      (channel) => {\n\n        channel = channel.data.data\n        console.log(channel)\n        channel.messages.push({\n          index: channel.messages.length + 1,\n          sender: client.id,\n          date: new Date(),\n          text: text\n        })\n\n        api.updateChannelById(channel.id, { data: { messages: channel.messages } }).then(res => { })\n\n      },\n      (error) => {\n        console.log(error)\n      }\n    )\n  }\n\n  function sendMessage(channel, text, client, recipients) {\n    socket.emit('send-message', { channelId: channel.id, recipients, date: new Date(), text })\n\n    addMessageToDatabase(channel, text, client)\n  }\n\n  // Cette fonction renvoie les données du client\n  function formattedChannel() {\n    return new Promise((resolve) => {\n\n      // Récupération des données du \"channel\" avec son id\n      api.getChannelById(selectedChannel.id).then(\n        (channel) => {\n\n          resolve(selectedChannel)\n\n        },\n        (error) => {\n          console.log(error)\n        }\n      )\n\n    })\n  }\n\n  function createChannel(payload) {\n    api.insertChannel(payload)\n  }\n\n  const value = {\n    channels,\n    setChannels,\n    messagesChannels,\n    setMessagesChannels,\n    selectedChannel,\n    setSelectedChannel,\n    createChannel,\n    formattedChannel,\n    sendMessage\n  }\n\n  return (\n    <ChannelsContext.Provider value={value}>\n      {children}\n    </ChannelsContext.Provider>\n  )\n}\n\nexport default ChannelsContext\n\n /*\n  conversations.map((conversation, index) => {\n    const recipients = conversation.recipients.map(recipient => {\n      const contact = contacts.find(contact => {\n        return contact.id === recipient\n      })\n      const name = (contact && contact.name) || recipient\n      return { id: recipient, name }\n    })\n\n    const messages = conversation.messages.map(message => {\n      const contact = contacts.find(contact => {\n        return contact.id === message.sender\n      })\n      const name = (contact && contact.name) || message.sender\n      const fromMe = id === message.sender\n      return { ...message, senderName: name, fromMe }\n    })\n\n    const selected = index === selectedConversationIndex\n    return { ...conversation, messages, recipients, selected }\n  })*/\n/*\n\nfunction arrayEquality(a, b) {\n  if (a.length !== b.length) return false\n\n  a.sort()\n  b.sort()\n\n  return a.every((element, index) => {\n    return element === b[index]\n  })\n}\n\nconst addMessageToChannel = useCallback(({ recipients, text, sender }) => {\n  setChannels(prevChannels => {\n    let madeChange = false\n    const newMessage = { sender, text }\n    const newChannels = prevChannels.map(channel => {\n      if (arrayEquality(channel.recipients, recipients)) {\n        madeChange = true\n        return {\n          ...channel,\n          messages: [...channel.messages, newMessage]\n        }\n      }\n\n      return channel\n    })\n\n    if (madeChange) {\n      return newChannels\n    } else {\n      return [\n        ...prevChannels,\n        { recipients, messages: [newMessage] }\n      ]\n    }\n  })\n}, [])*/\n/*\nconst addMessage = (message) => {\n  // J'isole les \"channels\" dans une variable\n  var allMessages = messagesChannelsRef.current\n\n  const indexMessage = allMessages.findIndex(messagesChannel => messagesChannel.id === message.channelId);\n  console.log(allMessages)\n  if (indexMessage !== -1) {\n    console.log(\"1\")\n    const oldMsg = allMessages[indexMessage].messages\n    setMessagesChannels(msg => [\n      ...msg.slice(0, indexMessage),\n      ...msg.slice(indexMessage + 1)\n    ]);\n    setMessagesChannels(msg => [...msg, { id: message.channelId, messages: [...oldMsg, {sender: message.sender, date: message.date, text: message.text}] }])\n  } else {\n    console.log(\"2\")\n    setMessagesChannels(msg => [...msg, { id: message.channelId, messages: [{sender: message.sender, date: message.date, text: message.text}] }])\n  }\n}*/"]},"metadata":{},"sourceType":"module"}