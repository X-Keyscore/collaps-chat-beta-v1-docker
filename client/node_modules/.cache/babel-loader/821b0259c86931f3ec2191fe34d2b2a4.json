{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\anton\\\\Desktop\\\\collaps-chat\\\\dev\\\\Beta\\\\V1\\\\client\\\\src\\\\contexts\\\\ChannelsProvider.js\";\nimport React, { useContext, useState, useEffect, useRef } from 'react';\nimport { useSocket } from './SocketProvider';\nimport api from \"../api\";\nconst ChannelsContext = React.createContext();\nexport function useChannels() {\n  return useContext(ChannelsContext);\n}\nexport function ChannelsProvider({\n  storageLocal,\n  children\n}) {\n  const id = storageLocal.id;\n  const token = storageLocal.token;\n  const socket = useSocket(); // https://stackoverflow.com/questions/54824036/useeffect-hook-with-socket-io-state-is-not-persistent-in-socket-handlers\n\n  const [channels, setChannels] = useState(null);\n  const channelsRef = useRef(channels);\n  useEffect(() => {\n    channelsRef.current = channels;\n  });\n  const [messagesChannels, setMessagesChannels] = useState([]);\n  const messagesChannelsRef = useRef(messagesChannels);\n  useEffect(() => {\n    messagesChannelsRef.current = messagesChannels;\n  });\n  const [selectedChannel, setSelectedChannel] = useState(null);\n  useEffect(() => {\n    if (socket == null) return; // channelId, sender, date, text\n\n    const addMessage = message => {\n      console.log(message); // J'isole les \"channels\" dans une variable\n\n      var allMessages = messagesChannelsRef.current; // Récuépration de l'index\n\n      const indexMessage = allMessages.findIndex(messagesChannel => messagesChannel.id === message.channelId);\n\n      if (indexMessage !== -1) {\n        // Copie de l'ancien tableau de données\n        let newArr = [...messagesChannelsRef.current]; // Ajout du nouveau message\n\n        newArr[indexMessage].messages = [...newArr[indexMessage].messages, {\n          sender: message.sender,\n          date: message.date,\n          text: message.text\n        }]; // Envoie des données dans le \"useState\"\n\n        setMessagesChannels(newArr);\n      } else {\n        // Ajout du message dans le \"useState\"\n        setMessagesChannels(msg => [...msg, {\n          id: message.channelId,\n          messages: [{\n            sender: message.sender,\n            date: message.date,\n            text: message.text\n          }]\n        }]);\n      }\n    }; // Si je reçoi un message je l'ajoute dans le \"channel\" qui lui correspond\n\n\n    socket.on('receive-message', addMessage);\n    return () => socket.off('receive-message', addMessage);\n  }, [socket]);\n\n  function addMessageToDatabase(message) {\n    // Récupération des données du \"channel\" avec son id\n    api.getChannelById(message.channel.id).then(channel => {\n      channel = channel.data.channel;\n      channel.messages.push({\n        sender: message.sender.id,\n        date: message.date,\n        text: message.text\n      });\n      api.updateChannelById(channel.id, {\n        data: {\n          messages: channel.messages\n        }\n      }).then(res => {});\n    }, error => {\n      console.log(error);\n    });\n  } // channel, text, client\n\n\n  function sendMessage(channel, text, file, client) {\n    const addMessage = message => {\n      // J'isole les \"channels\" dans une variable\n      var allMessages = messagesChannelsRef.current; // Récuépration de l'index\n\n      const indexMessage = allMessages.findIndex(messagesChannel => messagesChannel.id === message.channelId);\n\n      if (indexMessage !== -1) {\n        // Copie de l'ancien tableau de données\n        let newArr = [...messagesChannelsRef.current]; // Ajout du nouveau message\n\n        newArr[indexMessage].messages = [...newArr[indexMessage].messages, {\n          sender: message.sender,\n          date: message.date,\n          text: message.text,\n          file: message.file\n        }]; // Envoie des données dans le \"useState\"\n\n        setMessagesChannels(newArr);\n      } else {\n        // Ajout du message dans le \"useState\"\n        setMessagesChannels(msg => [...msg, {\n          id: message.channelId,\n          messages: [{\n            sender: message.sender,\n            date: message.date,\n            text: message.text,\n            file: message.file\n          }]\n        }]);\n      }\n    };\n\n    const date = new Date(); // channelId, sender, date, text\n\n    addMessage({\n      channelId: channel.id,\n      sender: {\n        id: client.id,\n        pseudo: client.pseudo\n      },\n      date,\n      text,\n      file\n    }); // recipients, channelId, sender, date, text\n\n    socket.emit('send-message', {\n      recipients: channel.recipients,\n      channelId: channel.id,\n      sender: {\n        id: client.id,\n        pseudo: client.pseudo\n      },\n      date,\n      text,\n      file: message.file\n    }); // channel, sender, date, text\n\n    addMessageToDatabase({\n      channel,\n      sender: {\n        id: client.id,\n        pseudo: client.pseudo\n      },\n      date,\n      text\n    });\n  }\n\n  function createChannel(payload) {\n    return new Promise(resolve => {\n      api.insertChannel(payload).then(res => {\n        return resolve(res.data);\n      });\n    });\n  }\n\n  const value = {\n    channels,\n    setChannels,\n    messagesChannels,\n    setMessagesChannels,\n    selectedChannel,\n    setSelectedChannel,\n    createChannel,\n    sendMessage\n  };\n  return /*#__PURE__*/React.createElement(ChannelsContext.Provider, {\n    value: value,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 140,\n      columnNumber: 5\n    }\n  }, children);\n}\nexport default ChannelsContext;","map":{"version":3,"sources":["C:/Users/anton/Desktop/collaps-chat/dev/Beta/V1/client/src/contexts/ChannelsProvider.js"],"names":["React","useContext","useState","useEffect","useRef","useSocket","api","ChannelsContext","createContext","useChannels","ChannelsProvider","storageLocal","children","id","token","socket","channels","setChannels","channelsRef","current","messagesChannels","setMessagesChannels","messagesChannelsRef","selectedChannel","setSelectedChannel","addMessage","message","console","log","allMessages","indexMessage","findIndex","messagesChannel","channelId","newArr","messages","sender","date","text","msg","on","off","addMessageToDatabase","getChannelById","channel","then","data","push","updateChannelById","res","error","sendMessage","file","client","Date","pseudo","emit","recipients","createChannel","payload","Promise","resolve","insertChannel","value"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,UAAhB,EAA4BC,QAA5B,EAAsCC,SAAtC,EAAiDC,MAAjD,QAA+D,OAA/D;AACA,SAASC,SAAT,QAA0B,kBAA1B;AACA,OAAOC,GAAP,MAAgB,QAAhB;AAEA,MAAMC,eAAe,GAAGP,KAAK,CAACQ,aAAN,EAAxB;AAEA,OAAO,SAASC,WAAT,GAAuB;AAC5B,SAAOR,UAAU,CAACM,eAAD,CAAjB;AACD;AAED,OAAO,SAASG,gBAAT,CAA0B;AAAEC,EAAAA,YAAF;AAAgBC,EAAAA;AAAhB,CAA1B,EAAsD;AAC3D,QAAMC,EAAE,GAAGF,YAAY,CAACE,EAAxB;AACA,QAAMC,KAAK,GAAGH,YAAY,CAACG,KAA3B;AAEA,QAAMC,MAAM,GAAGV,SAAS,EAAxB,CAJ2D,CAK3D;;AACA,QAAM,CAACW,QAAD,EAAWC,WAAX,IAA0Bf,QAAQ,CAAC,IAAD,CAAxC;AACA,QAAMgB,WAAW,GAAGd,MAAM,CAACY,QAAD,CAA1B;AACAb,EAAAA,SAAS,CAAC,MAAM;AACde,IAAAA,WAAW,CAACC,OAAZ,GAAsBH,QAAtB;AACD,GAFQ,CAAT;AAIA,QAAM,CAACI,gBAAD,EAAmBC,mBAAnB,IAA0CnB,QAAQ,CAAC,EAAD,CAAxD;AACA,QAAMoB,mBAAmB,GAAGlB,MAAM,CAACgB,gBAAD,CAAlC;AACAjB,EAAAA,SAAS,CAAC,MAAM;AACdmB,IAAAA,mBAAmB,CAACH,OAApB,GAA8BC,gBAA9B;AACD,GAFQ,CAAT;AAIA,QAAM,CAACG,eAAD,EAAkBC,kBAAlB,IAAwCtB,QAAQ,CAAC,IAAD,CAAtD;AAEAC,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIY,MAAM,IAAI,IAAd,EAAoB,OADN,CAGd;;AACA,UAAMU,UAAU,GAAIC,OAAD,IAAa;AAC9BC,MAAAA,OAAO,CAACC,GAAR,CAAYF,OAAZ,EAD8B,CAE9B;;AACA,UAAIG,WAAW,GAAGP,mBAAmB,CAACH,OAAtC,CAH8B,CAK9B;;AACA,YAAMW,YAAY,GAAGD,WAAW,CAACE,SAAZ,CAAsBC,eAAe,IAAIA,eAAe,CAACnB,EAAhB,KAAuBa,OAAO,CAACO,SAAxE,CAArB;;AAEA,UAAIH,YAAY,KAAK,CAAC,CAAtB,EAAyB;AACvB;AACA,YAAII,MAAM,GAAG,CAAC,GAAGZ,mBAAmB,CAACH,OAAxB,CAAb,CAFuB,CAGvB;;AACAe,QAAAA,MAAM,CAACJ,YAAD,CAAN,CAAqBK,QAArB,GAAgC,CAAC,GAAGD,MAAM,CAACJ,YAAD,CAAN,CAAqBK,QAAzB,EAAmC;AAAEC,UAAAA,MAAM,EAAEV,OAAO,CAACU,MAAlB;AAA0BC,UAAAA,IAAI,EAAEX,OAAO,CAACW,IAAxC;AAA8CC,UAAAA,IAAI,EAAEZ,OAAO,CAACY;AAA5D,SAAnC,CAAhC,CAJuB,CAKvB;;AACAjB,QAAAA,mBAAmB,CAACa,MAAD,CAAnB;AACD,OAPD,MAOO;AACL;AACAb,QAAAA,mBAAmB,CAACkB,GAAG,IAAI,CAAC,GAAGA,GAAJ,EAAS;AAAE1B,UAAAA,EAAE,EAAEa,OAAO,CAACO,SAAd;AAAyBE,UAAAA,QAAQ,EAAE,CAAC;AAAEC,YAAAA,MAAM,EAAEV,OAAO,CAACU,MAAlB;AAA0BC,YAAAA,IAAI,EAAEX,OAAO,CAACW,IAAxC;AAA8CC,YAAAA,IAAI,EAAEZ,OAAO,CAACY;AAA5D,WAAD;AAAnC,SAAT,CAAR,CAAnB;AACD;AACF,KAnBD,CAJc,CAyBd;;;AACAvB,IAAAA,MAAM,CAACyB,EAAP,CAAU,iBAAV,EAA6Bf,UAA7B;AAEA,WAAO,MAAMV,MAAM,CAAC0B,GAAP,CAAW,iBAAX,EAA8BhB,UAA9B,CAAb;AACD,GA7BQ,EA6BN,CAACV,MAAD,CA7BM,CAAT;;AA+BA,WAAS2B,oBAAT,CAA8BhB,OAA9B,EAAuC;AACrC;AACApB,IAAAA,GAAG,CAACqC,cAAJ,CAAmBjB,OAAO,CAACkB,OAAR,CAAgB/B,EAAnC,EAAuCgC,IAAvC,CACGD,OAAD,IAAa;AAEXA,MAAAA,OAAO,GAAGA,OAAO,CAACE,IAAR,CAAaF,OAAvB;AAEAA,MAAAA,OAAO,CAACT,QAAR,CAAiBY,IAAjB,CAAsB;AACpBX,QAAAA,MAAM,EAAEV,OAAO,CAACU,MAAR,CAAevB,EADH;AAEpBwB,QAAAA,IAAI,EAAEX,OAAO,CAACW,IAFM;AAGpBC,QAAAA,IAAI,EAAEZ,OAAO,CAACY;AAHM,OAAtB;AAMAhC,MAAAA,GAAG,CAAC0C,iBAAJ,CAAsBJ,OAAO,CAAC/B,EAA9B,EAAkC;AAAEiC,QAAAA,IAAI,EAAE;AAAEX,UAAAA,QAAQ,EAAES,OAAO,CAACT;AAApB;AAAR,OAAlC,EAA4EU,IAA5E,CAAiFI,GAAG,IAAI,CAAG,CAA3F;AAED,KAbH,EAcGC,KAAD,IAAW;AACTvB,MAAAA,OAAO,CAACC,GAAR,CAAYsB,KAAZ;AACD,KAhBH;AAkBD,GAvE0D,CAyE3D;;;AACA,WAASC,WAAT,CAAqBP,OAArB,EAA8BN,IAA9B,EAAoCc,IAApC,EAA0CC,MAA1C,EAAkD;AAEhD,UAAM5B,UAAU,GAAIC,OAAD,IAAa;AAE9B;AACA,UAAIG,WAAW,GAAGP,mBAAmB,CAACH,OAAtC,CAH8B,CAK9B;;AACA,YAAMW,YAAY,GAAGD,WAAW,CAACE,SAAZ,CAAsBC,eAAe,IAAIA,eAAe,CAACnB,EAAhB,KAAuBa,OAAO,CAACO,SAAxE,CAArB;;AAEA,UAAIH,YAAY,KAAK,CAAC,CAAtB,EAAyB;AACvB;AACA,YAAII,MAAM,GAAG,CAAC,GAAGZ,mBAAmB,CAACH,OAAxB,CAAb,CAFuB,CAGvB;;AACAe,QAAAA,MAAM,CAACJ,YAAD,CAAN,CAAqBK,QAArB,GAAgC,CAAC,GAAGD,MAAM,CAACJ,YAAD,CAAN,CAAqBK,QAAzB,EAAmC;AAAEC,UAAAA,MAAM,EAAEV,OAAO,CAACU,MAAlB;AAA0BC,UAAAA,IAAI,EAAEX,OAAO,CAACW,IAAxC;AAA8CC,UAAAA,IAAI,EAAEZ,OAAO,CAACY,IAA5D;AAAkEc,UAAAA,IAAI,EAAE1B,OAAO,CAAC0B;AAAhF,SAAnC,CAAhC,CAJuB,CAMvB;;AACA/B,QAAAA,mBAAmB,CAACa,MAAD,CAAnB;AACD,OARD,MAQO;AACL;AACAb,QAAAA,mBAAmB,CAACkB,GAAG,IAAI,CAAC,GAAGA,GAAJ,EAAS;AAAE1B,UAAAA,EAAE,EAAEa,OAAO,CAACO,SAAd;AAAyBE,UAAAA,QAAQ,EAAE,CAAC;AAAEC,YAAAA,MAAM,EAAEV,OAAO,CAACU,MAAlB;AAA0BC,YAAAA,IAAI,EAAEX,OAAO,CAACW,IAAxC;AAA8CC,YAAAA,IAAI,EAAEZ,OAAO,CAACY,IAA5D;AAAkEc,YAAAA,IAAI,EAAE1B,OAAO,CAAC0B;AAAhF,WAAD;AAAnC,SAAT,CAAR,CAAnB;AACD;AACF,KApBD;;AAsBA,UAAMf,IAAI,GAAG,IAAIiB,IAAJ,EAAb,CAxBgD,CA0BhD;;AACA7B,IAAAA,UAAU,CAAC;AAAEQ,MAAAA,SAAS,EAAEW,OAAO,CAAC/B,EAArB;AAAyBuB,MAAAA,MAAM,EAAE;AAAEvB,QAAAA,EAAE,EAAEwC,MAAM,CAACxC,EAAb;AAAiB0C,QAAAA,MAAM,EAAEF,MAAM,CAACE;AAAhC,OAAjC;AAA2ElB,MAAAA,IAA3E;AAAiFC,MAAAA,IAAjF;AAAuFc,MAAAA;AAAvF,KAAD,CAAV,CA3BgD,CA4BhD;;AACArC,IAAAA,MAAM,CAACyC,IAAP,CAAY,cAAZ,EAA4B;AAAEC,MAAAA,UAAU,EAAEb,OAAO,CAACa,UAAtB;AAAkCxB,MAAAA,SAAS,EAAEW,OAAO,CAAC/B,EAArD;AAAyDuB,MAAAA,MAAM,EAAE;AAAEvB,QAAAA,EAAE,EAAEwC,MAAM,CAACxC,EAAb;AAAiB0C,QAAAA,MAAM,EAAEF,MAAM,CAACE;AAAhC,OAAjE;AAA2GlB,MAAAA,IAA3G;AAAiHC,MAAAA,IAAjH;AAAuHc,MAAAA,IAAI,EAAE1B,OAAO,CAAC0B;AAArI,KAA5B,EA7BgD,CA8BhD;;AACAV,IAAAA,oBAAoB,CAAC;AAAEE,MAAAA,OAAF;AAAWR,MAAAA,MAAM,EAAE;AAAEvB,QAAAA,EAAE,EAAEwC,MAAM,CAACxC,EAAb;AAAiB0C,QAAAA,MAAM,EAAEF,MAAM,CAACE;AAAhC,OAAnB;AAA6DlB,MAAAA,IAA7D;AAAmEC,MAAAA;AAAnE,KAAD,CAApB;AAED;;AAED,WAASoB,aAAT,CAAuBC,OAAvB,EAAgC;AAC9B,WAAO,IAAIC,OAAJ,CAAaC,OAAD,IAAa;AAC9BvD,MAAAA,GAAG,CAACwD,aAAJ,CAAkBH,OAAlB,EAA2Bd,IAA3B,CAAgCI,GAAG,IAAI;AACrC,eAAOY,OAAO,CAACZ,GAAG,CAACH,IAAL,CAAd;AACD,OAFD;AAGD,KAJM,CAAP;AAKD;;AAED,QAAMiB,KAAK,GAAG;AACZ/C,IAAAA,QADY;AAEZC,IAAAA,WAFY;AAGZG,IAAAA,gBAHY;AAIZC,IAAAA,mBAJY;AAKZE,IAAAA,eALY;AAMZC,IAAAA,kBANY;AAOZkC,IAAAA,aAPY;AAQZP,IAAAA;AARY,GAAd;AAWA,sBACE,oBAAC,eAAD,CAAiB,QAAjB;AAA0B,IAAA,KAAK,EAAEY,KAAjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACGnD,QADH,CADF;AAKD;AAED,eAAeL,eAAf","sourcesContent":["import React, { useContext, useState, useEffect, useRef } from 'react'\nimport { useSocket } from './SocketProvider';\nimport api from \"../api\"\n\nconst ChannelsContext = React.createContext()\n\nexport function useChannels() {\n  return useContext(ChannelsContext)\n}\n\nexport function ChannelsProvider({ storageLocal, children }) {\n  const id = storageLocal.id\n  const token = storageLocal.token\n\n  const socket = useSocket()\n  // https://stackoverflow.com/questions/54824036/useeffect-hook-with-socket-io-state-is-not-persistent-in-socket-handlers\n  const [channels, setChannels] = useState(null)\n  const channelsRef = useRef(channels);\n  useEffect(() => {\n    channelsRef.current = channels;\n  });\n\n  const [messagesChannels, setMessagesChannels] = useState([])\n  const messagesChannelsRef = useRef(messagesChannels);\n  useEffect(() => {\n    messagesChannelsRef.current = messagesChannels;\n  });\n\n  const [selectedChannel, setSelectedChannel] = useState(null)\n\n  useEffect(() => {\n    if (socket == null) return\n\n    // channelId, sender, date, text\n    const addMessage = (message) => {\n      console.log(message)\n      // J'isole les \"channels\" dans une variable\n      var allMessages = messagesChannelsRef.current\n\n      // Récuépration de l'index\n      const indexMessage = allMessages.findIndex(messagesChannel => messagesChannel.id === message.channelId);\n\n      if (indexMessage !== -1) {\n        // Copie de l'ancien tableau de données\n        let newArr = [...messagesChannelsRef.current];\n        // Ajout du nouveau message\n        newArr[indexMessage].messages = [...newArr[indexMessage].messages, { sender: message.sender, date: message.date, text: message.text }];\n        // Envoie des données dans le \"useState\"\n        setMessagesChannels(newArr);\n      } else {\n        // Ajout du message dans le \"useState\"\n        setMessagesChannels(msg => [...msg, { id: message.channelId, messages: [{ sender: message.sender, date: message.date, text: message.text }] }])\n      }\n    }\n\n    // Si je reçoi un message je l'ajoute dans le \"channel\" qui lui correspond\n    socket.on('receive-message', addMessage);\n\n    return () => socket.off('receive-message', addMessage)\n  }, [socket])\n\n  function addMessageToDatabase(message) {\n    // Récupération des données du \"channel\" avec son id\n    api.getChannelById(message.channel.id).then(\n      (channel) => {\n\n        channel = channel.data.channel\n\n        channel.messages.push({\n          sender: message.sender.id,\n          date: message.date,\n          text: message.text\n        })\n\n        api.updateChannelById(channel.id, { data: { messages: channel.messages } }).then(res => { })\n\n      },\n      (error) => {\n        console.log(error)\n      }\n    )\n  }\n\n  // channel, text, client\n  function sendMessage(channel, text, file, client) {\n\n    const addMessage = (message) => {\n\n      // J'isole les \"channels\" dans une variable\n      var allMessages = messagesChannelsRef.current\n\n      // Récuépration de l'index\n      const indexMessage = allMessages.findIndex(messagesChannel => messagesChannel.id === message.channelId);\n\n      if (indexMessage !== -1) {\n        // Copie de l'ancien tableau de données\n        let newArr = [...messagesChannelsRef.current];\n        // Ajout du nouveau message\n        newArr[indexMessage].messages = [...newArr[indexMessage].messages, { sender: message.sender, date: message.date, text: message.text, file: message.file }];\n\n        // Envoie des données dans le \"useState\"\n        setMessagesChannels(newArr);\n      } else {\n        // Ajout du message dans le \"useState\"\n        setMessagesChannels(msg => [...msg, { id: message.channelId, messages: [{ sender: message.sender, date: message.date, text: message.text, file: message.file }] }])\n      }\n    }\n\n    const date = new Date()\n\n    // channelId, sender, date, text\n    addMessage({ channelId: channel.id, sender: { id: client.id, pseudo: client.pseudo }, date, text, file })\n    // recipients, channelId, sender, date, text\n    socket.emit('send-message', { recipients: channel.recipients, channelId: channel.id, sender: { id: client.id, pseudo: client.pseudo }, date, text, file: message.file })\n    // channel, sender, date, text\n    addMessageToDatabase({ channel, sender: { id: client.id, pseudo: client.pseudo }, date, text })\n\n  }\n\n  function createChannel(payload) {\n    return new Promise((resolve) => {\n      api.insertChannel(payload).then(res => {\n        return resolve(res.data)\n      })\n    })\n  }\n\n  const value = {\n    channels,\n    setChannels,\n    messagesChannels,\n    setMessagesChannels,\n    selectedChannel,\n    setSelectedChannel,\n    createChannel,\n    sendMessage\n  }\n\n  return (\n    <ChannelsContext.Provider value={value}>\n      {children}\n    </ChannelsContext.Provider>\n  )\n}\n\nexport default ChannelsContext"]},"metadata":{},"sourceType":"module"}