{"ast":null,"code":"import { useEffect, useState, useCallback } from 'react';\nimport useLocalStorage from '../hooks/useLocalStorage';\nimport api from \"../api\"; // Cette fonction renvoie les données du client\n// - Par défaut elle renvoie les données brutes\n// - Si le type est \"cross\" elle renvoie les données croisées\n\nfunction getClient(id) {\n  return new Promise(resolve => {\n    api.getUserById(id).then(user => {\n      // Constante pour stocker les données brutes du cleint\n      const clientRaw = user.data.data; // Si le client n'a pas de constact j'envoie directement les données\n\n      if (clientRaw.channels.length === 0) return resolve(clientRaw); // Variable pour stocker les données croisées du cleint\n\n      var clientCross = user.data.data; // Je filtre pour ne récupérer que les contacts privés\n\n      clientCross.channels.filter(channel => channel.type === \"private\").forEach((channel, index) => {\n        // Je récupère les informations sur le destinataire grace à sont id\n        api.getUserById(channel.recipients.id).then(recipient => {\n          // Si le destinataire n'existe plus je le supprime des données du client\n          if (recipient.data.data === null) {\n            // Je boucle tous les \"channels\" du client\n            for (let i = 0; i < clientCross.channels.length; i++) {\n              // Je teste si l'id du \"channel\" sélectionné correspond à l'id du \"channel\" passé dans la boucle\n              if (clientCross.channels[i].recipients.id === channel.recipients.id) {\n                // Je supprime le \"channel\" dans la liste grace à sa position\n                clientCross.channels.splice(i, 1); // Je mets à jour le client\n\n                return api.updateUserById(clientCross.id, {\n                  data: {\n                    channels: clientCross.channels\n                  }\n                }).then(res => {\n                  /*//EN COURS// Système gestion des erreurs*/\n                });\n              }\n            }\n          } // Je complète les informations existantes du destinataire avec celle de la base de données\n\n\n          channel.recipients = recipient.data.data; // J'ajoute un element \"selected\" à \"channel\" est passe la valeur \"true\" au premier\n\n          Object.assign(channel, {\n            selected: false\n          });\n          Object.assign(channel, {\n            key: index\n          }); // Je mets à jour l'object \"channels\" du client \n\n          clientCross.channels[index] = channel;\n          if (clientRaw.channels.length === index + 1) return resolve(clientCross);\n        });\n      });\n    });\n  });\n}\n\nexport default function useExternalStorage() {\n  // Initialisation du \"useState\" pour stocké les données\n  const [value, setValue] = useState(null); // Récupération de l'id du client pour pouvoir identifier la cible de la requête\n\n  const [id] = useLocalStorage('id');\n  const fetchMyAPI = useCallback(async () => {\n    const client = await getClient(id);\n    setValue(client);\n  }, []); // Le \"useEffect\" est utilisé pour géré l'asynchrone\n\n  useEffect(() => {\n    fetchMyAPI();\n  }, [fetchMyAPI]);\n  return [value, setValue];\n}","map":{"version":3,"sources":["C:/Users/anton/Desktop/FInt.Tchat/dev/V10/client/src/hooks/useExternalStorage.js"],"names":["useEffect","useState","useCallback","useLocalStorage","api","getClient","id","Promise","resolve","getUserById","then","user","clientRaw","data","channels","length","clientCross","filter","channel","type","forEach","index","recipients","recipient","i","splice","updateUserById","res","Object","assign","selected","key","useExternalStorage","value","setValue","fetchMyAPI","client"],"mappings":"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","sourcesContent":["import { useEffect, useState, useCallback } from 'react';\nimport useLocalStorage from '../hooks/useLocalStorage';\nimport api from \"../api\"\n\n// Cette fonction renvoie les données du client\n// - Par défaut elle renvoie les données brutes\n// - Si le type est \"cross\" elle renvoie les données croisées\nfunction getClient(id) {\n  return new Promise((resolve) => {\n    api.getUserById(id).then(\n      (user) => {\n        // Constante pour stocker les données brutes du cleint\n        const clientRaw = user.data.data\n\n        // Si le client n'a pas de constact j'envoie directement les données\n        if (clientRaw.channels.length === 0) return resolve(clientRaw)\n\n        // Variable pour stocker les données croisées du cleint\n        var clientCross = user.data.data\n\n        // Je filtre pour ne récupérer que les contacts privés\n        clientCross.channels.filter(channel => channel.type === \"private\").forEach((channel, index) => {\n\n          // Je récupère les informations sur le destinataire grace à sont id\n          api.getUserById(channel.recipients.id).then((recipient) => {\n\n            // Si le destinataire n'existe plus je le supprime des données du client\n            if (recipient.data.data === null) {\n              // Je boucle tous les \"channels\" du client\n              for (let i = 0; i < clientCross.channels.length; i++) {\n                // Je teste si l'id du \"channel\" sélectionné correspond à l'id du \"channel\" passé dans la boucle\n                if (clientCross.channels[i].recipients.id === channel.recipients.id) {\n                  // Je supprime le \"channel\" dans la liste grace à sa position\n                  clientCross.channels.splice(i, 1);\n                  // Je mets à jour le client\n                  return api.updateUserById(clientCross.id, { data: { channels: clientCross.channels } }).then(res => {/*//EN COURS// Système gestion des erreurs*/ })\n                }\n              }\n            }\n\n            // Je complète les informations existantes du destinataire avec celle de la base de données\n            channel.recipients = recipient.data.data\n\n            // J'ajoute un element \"selected\" à \"channel\" est passe la valeur \"true\" au premier\n            Object.assign(channel, { selected: false })\n            Object.assign(channel, { key: index })\n\n            // Je mets à jour l'object \"channels\" du client \n            clientCross.channels[index] = channel\n\n            if (clientRaw.channels.length === index + 1) return resolve(clientCross)\n\n          });\n        })\n      })\n  })\n}\n\nexport default function useExternalStorage() {\n  // Initialisation du \"useState\" pour stocké les données\n  const [value, setValue] = useState(null);\n  // Récupération de l'id du client pour pouvoir identifier la cible de la requête\n  const [id] = useLocalStorage('id')\n\n  const fetchMyAPI = useCallback(async () => {\n    const client = await getClient(id)\n    setValue(client);\n  }, [])\n\n  // Le \"useEffect\" est utilisé pour géré l'asynchrone\n  useEffect(() => {\n    fetchMyAPI()\n  }, [fetchMyAPI])\n\n  return [value, setValue]\n}"]},"metadata":{},"sourceType":"module"}