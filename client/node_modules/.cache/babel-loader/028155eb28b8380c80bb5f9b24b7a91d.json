{"ast":null,"code":"import { useEffect, useState } from 'react';\nimport api from \"../api\"; // Cette fonction renvoie les données du client\n// - Par défaut elle renvoie les données brutes\n// - Si le type est \"cross\" elle renvoie les données croisées\n\nfunction getClient(id) {\n  return new Promise(resolve => {\n    api.getUserById(id).then(user => {\n      // Constante pour stocker les données brutes du cleint\n      const clientRaw = user.data.data; // Si le client n'a pas de constact j'envoie directement les données\n\n      if (clientRaw.channels.length === 0) return resolve(clientRaw); // Variable pour stocker les données croisées du cleint\n\n      var clientCross = user.data.data; // Je filtre pour ne récupérer que les contacts privés\n\n      clientCross.channels.filter(channel => channel.type === \"private\").forEach((channel, index) => {\n        // Je récupère les informations sur le destinataire grace à sont id\n        api.getUserById(channel.recipients.id).then(recipient => {\n          // Si le destinataire n'existe plus je le supprime des données du client\n          if (recipient.data.data === null) {\n            // Je boucle tous les \"channels\" du client\n            for (let i = 0; i < clientCross.channels.length; i++) {\n              // Je teste si l'id du \"channel\" sélectionné correspond à l'id du \"channel\" passé dans la boucle\n              if (clientCross.channels[i].recipients.id === channel.recipients.id) {\n                // Je supprime le \"channel\" dans la liste grace à sa position\n                clientCross.channels.splice(i, 1); // Je mets à jour le client\n\n                return api.updateUserById(clientCross.id, {\n                  data: {\n                    channels: clientCross.channels\n                  }\n                }).then(res => {\n                  /*//EN COURS// Système gestion des erreurs*/\n                });\n              }\n            }\n          } // Je complète les informations existantes du destinataire avec celle de la base de données\n\n\n          channel.recipients = recipient.data.data; // J'ajoute un element \"selected\" à \"channel\" est passe la valeur \"true\" au premier\n\n          Object.assign(channel, {\n            selected: false\n          });\n          Object.assign(channel, {\n            key: index\n          }); // Je mets à jour l'object \"channels\" du client \n\n          clientCross.channels[index] = channel;\n          if (clientRaw.channels.length === index + 1) return resolve(clientCross), console.log(\"update client in userProvider\");\n        });\n      });\n    });\n  });\n}\n\nexport default function useExternalStorage(id, initialValue) {\n  const [client, setClient] = useState(() => {\n    console.log(id);\n    const jsonValue = getClient(id); // api value client\n\n    if (jsonValue != null) return jsonValue;\n\n    if (typeof initialValue === 'function') {\n      return initialValue();\n    } else {\n      return initialValue;\n    }\n  });\n  useEffect(() => {\n    // Je ne stock rien si il n'y a pas de clé\n    if (client != null) api.updateUserById(id, client).then(res => {\n      /*//EN COURS// Système gestion des erreurs*/\n    });\n  }, [client]);\n  return [client, setClient];\n}","map":{"version":3,"sources":["C:/Users/anton/Desktop/FInt.Tchat/dev/V10/client/src/hooks/useExternalStorage.js"],"names":["useEffect","useState","api","getClient","id","Promise","resolve","getUserById","then","user","clientRaw","data","channels","length","clientCross","filter","channel","type","forEach","index","recipients","recipient","i","splice","updateUserById","res","Object","assign","selected","key","console","log","useExternalStorage","initialValue","client","setClient","jsonValue"],"mappings":"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","sourcesContent":["import { useEffect, useState } from 'react';\nimport api from \"../api\"\n\n// Cette fonction renvoie les données du client\n// - Par défaut elle renvoie les données brutes\n// - Si le type est \"cross\" elle renvoie les données croisées\nfunction getClient(id) {\n  return new Promise((resolve) => {\n    api.getUserById(id).then(\n      (user) => {\n        // Constante pour stocker les données brutes du cleint\n        const clientRaw = user.data.data\n\n        // Si le client n'a pas de constact j'envoie directement les données\n        if (clientRaw.channels.length === 0) return resolve(clientRaw)\n\n        // Variable pour stocker les données croisées du cleint\n        var clientCross = user.data.data\n\n        // Je filtre pour ne récupérer que les contacts privés\n        clientCross.channels.filter(channel => channel.type === \"private\").forEach((channel, index) => {\n\n          // Je récupère les informations sur le destinataire grace à sont id\n          api.getUserById(channel.recipients.id).then((recipient) => {\n\n            // Si le destinataire n'existe plus je le supprime des données du client\n            if (recipient.data.data === null) {\n              // Je boucle tous les \"channels\" du client\n              for (let i = 0; i < clientCross.channels.length; i++) {\n                // Je teste si l'id du \"channel\" sélectionné correspond à l'id du \"channel\" passé dans la boucle\n                if (clientCross.channels[i].recipients.id === channel.recipients.id) {\n                  // Je supprime le \"channel\" dans la liste grace à sa position\n                  clientCross.channels.splice(i, 1);\n                  // Je mets à jour le client\n                  return api.updateUserById(clientCross.id, { data: { channels: clientCross.channels } }).then(res => {/*//EN COURS// Système gestion des erreurs*/ })\n                }\n              }\n            }\n\n            // Je complète les informations existantes du destinataire avec celle de la base de données\n            channel.recipients = recipient.data.data\n\n            // J'ajoute un element \"selected\" à \"channel\" est passe la valeur \"true\" au premier\n            Object.assign(channel, { selected: false })\n            Object.assign(channel, { key: index })\n\n            // Je mets à jour l'object \"channels\" du client \n            clientCross.channels[index] = channel\n\n            if (clientRaw.channels.length === index + 1) return resolve(clientCross), console.log(\"update client in userProvider\")\n\n          });\n        })\n      })\n  })\n}\n\nexport default function useExternalStorage(id, initialValue) {\n  const [client, setClient] = useState(() => {\n    console.log(id)\n    const jsonValue = getClient(id) // api value client\n\n    if (jsonValue != null) return jsonValue\n    if (typeof initialValue === 'function') {\n      return initialValue()\n    } else {\n      return initialValue\n    }\n  });\n\n  useEffect(() => {\n    // Je ne stock rien si il n'y a pas de clé\n    if (client != null) api.updateUserById(id, client).then(res => {/*//EN COURS// Système gestion des erreurs*/ })\n  }, [client])\n\n  return [client, setClient]\n}\n"]},"metadata":{},"sourceType":"module"}