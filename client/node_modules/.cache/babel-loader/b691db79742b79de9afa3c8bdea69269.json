{"ast":null,"code":"import _toConsumableArray from\"C:\\\\Users\\\\anton\\\\Desktop\\\\FInt.Tchat\\\\dev\\\\Beta\\\\V1\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";import _slicedToArray from\"C:\\\\Users\\\\anton\\\\Desktop\\\\FInt.Tchat\\\\dev\\\\Beta\\\\V1\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";import React,{useContext,useState,useEffect,useRef}from'react';import{useSocket}from'./SocketProvider';import api from\"../api\";var ChannelsContext=React.createContext();export function useChannels(){return useContext(ChannelsContext);}export function ChannelsProvider(_ref){var id=_ref.id,children=_ref.children;var socket=useSocket();// https://stackoverflow.com/questions/54824036/useeffect-hook-with-socket-io-state-is-not-persistent-in-socket-handlers\nvar _useState=useState(null),_useState2=_slicedToArray(_useState,2),channels=_useState2[0],setChannels=_useState2[1];var channelsRef=useRef(channels);useEffect(function(){channelsRef.current=channels;});var _useState3=useState([]),_useState4=_slicedToArray(_useState3,2),messagesChannels=_useState4[0],setMessagesChannels=_useState4[1];var messagesChannelsRef=useRef(messagesChannels);useEffect(function(){messagesChannelsRef.current=messagesChannels;});var _useState5=useState(null),_useState6=_slicedToArray(_useState5,2),selectedChannel=_useState6[0],setSelectedChannel=_useState6[1];useEffect(function(){if(socket==null)return;// channelId, sender, date, text\nvar addMessage=function addMessage(message){console.log(message);// J'isole les \"channels\" dans une variable\nvar allMessages=messagesChannelsRef.current;// Récuépration de l'index\nvar indexMessage=allMessages.findIndex(function(messagesChannel){return messagesChannel.id===message.channelId;});if(indexMessage!==-1){// Copie de l'ancien tableau de données\nvar newArr=_toConsumableArray(messagesChannelsRef.current);// Ajout du nouveau message\nnewArr[indexMessage].messages=[].concat(_toConsumableArray(newArr[indexMessage].messages),[{sender:message.sender,date:message.date,text:message.text}]);// Envoie des données dans le \"useState\"\nsetMessagesChannels(newArr);}else{// Ajout du message dans le \"useState\"\nsetMessagesChannels(function(msg){return[].concat(_toConsumableArray(msg),[{id:message.channelId,messages:[{sender:message.sender,date:message.date,text:message.text}]}]);});}};// Si je reçoi un message je l'ajoute dans le \"channel\" qui lui correspond\nsocket.on('receive-message',addMessage);return function(){return socket.off('receive-message',addMessage);};},[socket]);function addMessageToDatabase(message){// Récupération des données du \"channel\" avec son id\napi.getChannelById(message.channel.id).then(function(channel){channel=channel.data.data;channel.messages.push({sender:message.sender.id,date:message.date,text:message.text});api.updateChannelById(channel.id,{data:{messages:channel.messages}}).then(function(res){});},function(error){console.log(error);});}// channel, text, client\nfunction sendMessage(channel,text,client){var addMessage=function addMessage(message){// J'isole les \"channels\" dans une variable\nvar allMessages=messagesChannelsRef.current;// Récuépration de l'index\nvar indexMessage=allMessages.findIndex(function(messagesChannel){return messagesChannel.id===message.channelId;});if(indexMessage!==-1){// Copie de l'ancien tableau de données\nvar newArr=_toConsumableArray(messagesChannelsRef.current);// Ajout du nouveau message\nnewArr[indexMessage].messages=[].concat(_toConsumableArray(newArr[indexMessage].messages),[{sender:message.sender,date:message.date,text:message.text}]);console.log(newArr);// Envoie des données dans le \"useState\"\nsetMessagesChannels(newArr);}else{// Ajout du message dans le \"useState\"\nsetMessagesChannels(function(msg){return[].concat(_toConsumableArray(msg),[{id:message.channelId,messages:[{sender:message.sender,date:message.date,text:message.text}]}]);});}};var date=new Date();// channelId, sender, date, text\naddMessage({channelId:channel.id,sender:{id:client.id,pseudo:client.pseudo},date:date,text:text});// recipients, channelId, sender, date, text\nsocket.emit('send-message',{recipients:channel.recipients,channelId:channel.id,sender:{id:client.id,pseudo:client.pseudo},date:date,text:text});// channel, sender, date, text\naddMessageToDatabase({channel:channel,sender:{id:client.id,pseudo:client.pseudo},date:date,text:text});}function createChannel(payload){api.insertChannel(payload).then(function(res){});}var value={channels:channels,setChannels:setChannels,messagesChannels:messagesChannels,setMessagesChannels:setMessagesChannels,selectedChannel:selectedChannel,setSelectedChannel:setSelectedChannel,createChannel:createChannel,sendMessage:sendMessage};return/*#__PURE__*/React.createElement(ChannelsContext.Provider,{value:value},children);}export default ChannelsContext;","map":{"version":3,"sources":["C:/Users/anton/Desktop/FInt.Tchat/dev/Beta/V1/client/src/contexts/ChannelsProvider.js"],"names":["React","useContext","useState","useEffect","useRef","useSocket","api","ChannelsContext","createContext","useChannels","ChannelsProvider","id","children","socket","channels","setChannels","channelsRef","current","messagesChannels","setMessagesChannels","messagesChannelsRef","selectedChannel","setSelectedChannel","addMessage","message","console","log","allMessages","indexMessage","findIndex","messagesChannel","channelId","newArr","messages","sender","date","text","msg","on","off","addMessageToDatabase","getChannelById","channel","then","data","push","updateChannelById","res","error","sendMessage","client","Date","pseudo","emit","recipients","createChannel","payload","insertChannel","value"],"mappings":"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","sourcesContent":["import React, { useContext, useState, useEffect, useRef } from 'react'\nimport { useSocket } from './SocketProvider';\nimport api from \"../api\"\n\nconst ChannelsContext = React.createContext()\n\nexport function useChannels() {\n  return useContext(ChannelsContext)\n}\n\nexport function ChannelsProvider({ id, children }) {\n  const socket = useSocket()\n  // https://stackoverflow.com/questions/54824036/useeffect-hook-with-socket-io-state-is-not-persistent-in-socket-handlers\n  const [channels, setChannels] = useState(null)\n  const channelsRef = useRef(channels);\n  useEffect(() => {\n    channelsRef.current = channels;\n  });\n\n  const [messagesChannels, setMessagesChannels] = useState([])\n  const messagesChannelsRef = useRef(messagesChannels);\n  useEffect(() => {\n    messagesChannelsRef.current = messagesChannels;\n  });\n\n  const [selectedChannel, setSelectedChannel] = useState(null)\n\n  useEffect(() => {\n    if (socket == null) return\n\n    // channelId, sender, date, text\n    const addMessage = (message) => {\n      console.log(message)\n      // J'isole les \"channels\" dans une variable\n      var allMessages = messagesChannelsRef.current\n\n      // Récuépration de l'index\n      const indexMessage = allMessages.findIndex(messagesChannel => messagesChannel.id === message.channelId);\n\n      if (indexMessage !== -1) {\n        // Copie de l'ancien tableau de données\n        let newArr = [...messagesChannelsRef.current];\n        // Ajout du nouveau message\n        newArr[indexMessage].messages = [...newArr[indexMessage].messages, { sender: message.sender, date: message.date, text: message.text }];\n        // Envoie des données dans le \"useState\"\n        setMessagesChannels(newArr);\n      } else {\n        // Ajout du message dans le \"useState\"\n        setMessagesChannels(msg => [...msg, { id: message.channelId, messages: [{ sender: message.sender, date: message.date, text: message.text }] }])\n      }\n    }\n\n    // Si je reçoi un message je l'ajoute dans le \"channel\" qui lui correspond\n    socket.on('receive-message', addMessage);\n\n    return () => socket.off('receive-message', addMessage)\n  }, [socket])\n\n  function addMessageToDatabase(message) {\n    // Récupération des données du \"channel\" avec son id\n    api.getChannelById(message.channel.id).then(\n      (channel) => {\n\n        channel = channel.data.data\n\n        channel.messages.push({\n          sender: message.sender.id,\n          date: message.date,\n          text: message.text\n        })\n\n        api.updateChannelById(channel.id, { data: { messages: channel.messages } }).then(res => { })\n\n      },\n      (error) => {\n        console.log(error)\n      }\n    )\n  }\n\n  // channel, text, client\n  function sendMessage(channel, text, client) {\n\n    const addMessage = (message) => {\n\n      // J'isole les \"channels\" dans une variable\n      var allMessages = messagesChannelsRef.current\n\n      // Récuépration de l'index\n      const indexMessage = allMessages.findIndex(messagesChannel => messagesChannel.id === message.channelId);\n\n      if (indexMessage !== -1) {\n        // Copie de l'ancien tableau de données\n        let newArr = [...messagesChannelsRef.current];\n        // Ajout du nouveau message\n        newArr[indexMessage].messages = [...newArr[indexMessage].messages, { sender: message.sender, date: message.date, text: message.text }];\n        console.log(newArr)\n        // Envoie des données dans le \"useState\"\n        setMessagesChannels(newArr);\n      } else {\n        // Ajout du message dans le \"useState\"\n        setMessagesChannels(msg => [...msg, { id: message.channelId, messages: [{ sender: message.sender, date: message.date, text: message.text }] }])\n      }\n    }\n\n    const date = new Date()\n\n    // channelId, sender, date, text\n    addMessage({ channelId: channel.id, sender: { id: client.id, pseudo: client.pseudo }, date, text })\n    // recipients, channelId, sender, date, text\n    socket.emit('send-message', { recipients: channel.recipients, channelId: channel.id, sender: { id: client.id, pseudo: client.pseudo }, date, text })\n    // channel, sender, date, text\n    addMessageToDatabase({ channel, sender: { id: client.id, pseudo: client.pseudo }, date, text })\n\n  }\n\n  function createChannel(payload) {\n    api.insertChannel(payload).then(res => { })\n  }\n\n  const value = {\n    channels,\n    setChannels,\n    messagesChannels,\n    setMessagesChannels,\n    selectedChannel,\n    setSelectedChannel,\n    createChannel,\n    sendMessage\n  }\n\n  return (\n    <ChannelsContext.Provider value={value}>\n      {children}\n    </ChannelsContext.Provider>\n  )\n}\n\nexport default ChannelsContext"]},"metadata":{},"sourceType":"module"}