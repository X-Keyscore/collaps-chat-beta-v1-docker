{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\anton\\\\Desktop\\\\FInt.Tchat\\\\dev\\\\V10\\\\client\\\\src\\\\contexts\\\\ChannelsProvider.js\";\nimport React, { useContext, useState, useEffect } from 'react';\nimport { useSocket } from './SocketProvider';\nimport api from \"../api\";\nconst ChannelsContext = React.createContext();\nexport function useChannels() {\n  return useContext(ChannelsContext);\n}\nexport function ChannelsProvider({\n  id,\n  children\n}) {\n  const [selectedChannel, setSelectedChannel] = useState(null);\n  const socket = useSocket();\n\n  function addMessageToDatabase(channel, text, client, recipients) {\n    /*\n    // J'isole les données du client dans une variable pour pouvoir les modifier\n    var clientEdit = client\n    // Je boucle tous les \"channels\" du client\n    for (let i = 0; i < clientEdit.channels.length; i++) {\n      // Je teste si l'id du \"channel\" sélectionné correspond à l'id du \"channel\" passé dans la boucle\n      if (clientEdit.channels[i].id === channel.id) {\n        // J'ajoute le message aux données du client\n        clientEdit.channels[i].messages.push({\n          sender: client.id,\n          date: new Date(),\n          text: text\n        })\n        // Je mets à jour le client\n        api.updateUserById(clientEdit.id, { data: { channels: clientEdit.channels } }).then(res => {})\n      }\n    }\n     // Je boucle tous les destinataires\n    recipients.forEach(recipient => {\n      // J'isole les données du destinataire dans une variable pour pouvoir les modifier\n      var recipientEdit = recipient\n      // Je boucle tous les \"channels\" du destinataire\n      for (let i = 0; i < recipientEdit.channels.length; i++) {\n        // Je teste si l'id du \"channel\" sélectionné correspond à l'id du \"channel\" passé dans la boucle\n        if (recipientEdit.channels[i].id === channel.id) {\n          // J'ajoute le message aux données du destinataire\n          recipientEdit.channels[i].messages.push({\n            sender: client.id,\n            date: new Date(),\n            text: text\n          })\n          // Je mets à jour le destinataire\n          api.updateUserById(recipientEdit.id, { data: { channels: recipientEdit.channels } }).then(res => {})\n        }\n      }\n    });*/\n  }\n\n  function sendMessage(channel, text, client, recipients) {\n    socket.emit('send-message', {\n      recipients,\n      text\n    });\n    addMessageToDatabase(channel, text, client, recipients);\n  }\n\n  useEffect(() => {\n    if (socket == null) return;\n    socket.on('receive-message', data => {\n      console.log(data);\n    });\n    return () => socket.off('receive-message');\n  }, [socket]);\n  const value = {\n    selectedChannel,\n    setSelectedChannel,\n    sendMessage\n  };\n  return /*#__PURE__*/React.createElement(ChannelsContext.Provider, {\n    value: value,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 80,\n      columnNumber: 5\n    }\n  }, children);\n}\nexport default ChannelsContext;\n/*\n\nfunction arrayEquality(a, b) {\n  if (a.length !== b.length) return false\n\n  a.sort()\n  b.sort()\n\n  return a.every((element, index) => {\n    return element === b[index]\n  })\n}\n\nconst addMessageToChannel = useCallback(({ recipients, text, sender }) => {\n  setChannels(prevChannels => {\n    let madeChange = false\n    const newMessage = { sender, text }\n    const newChannels = prevChannels.map(channel => {\n      if (arrayEquality(channel.recipients, recipients)) {\n        madeChange = true\n        return {\n          ...channel,\n          messages: [...channel.messages, newMessage]\n        }\n      }\n\n      return channel\n    })\n\n    if (madeChange) {\n      return newChannels\n    } else {\n      return [\n        ...prevChannels,\n        { recipients, messages: [newMessage] }\n      ]\n    }\n  })\n}, [])*/","map":{"version":3,"sources":["C:/Users/anton/Desktop/FInt.Tchat/dev/V10/client/src/contexts/ChannelsProvider.js"],"names":["React","useContext","useState","useEffect","useSocket","api","ChannelsContext","createContext","useChannels","ChannelsProvider","id","children","selectedChannel","setSelectedChannel","socket","addMessageToDatabase","channel","text","client","recipients","sendMessage","emit","on","data","console","log","off","value"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,UAAhB,EAA4BC,QAA5B,EAAsCC,SAAtC,QAAuD,OAAvD;AACA,SAASC,SAAT,QAA0B,kBAA1B;AAEA,OAAOC,GAAP,MAAgB,QAAhB;AAEA,MAAMC,eAAe,GAAGN,KAAK,CAACO,aAAN,EAAxB;AAEA,OAAO,SAASC,WAAT,GAAuB;AAC5B,SAAOP,UAAU,CAACK,eAAD,CAAjB;AACD;AAED,OAAO,SAASG,gBAAT,CAA0B;AAAEC,EAAAA,EAAF;AAAMC,EAAAA;AAAN,CAA1B,EAA4C;AACjD,QAAM,CAACC,eAAD,EAAkBC,kBAAlB,IAAwCX,QAAQ,CAAC,IAAD,CAAtD;AACA,QAAMY,MAAM,GAAGV,SAAS,EAAxB;;AAEA,WAASW,oBAAT,CAA8BC,OAA9B,EAAuCC,IAAvC,EAA6CC,MAA7C,EAAqDC,UAArD,EAAiE;AAE/D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCD;;AAED,WAASC,WAAT,CAAqBJ,OAArB,EAA8BC,IAA9B,EAAoCC,MAApC,EAA4CC,UAA5C,EAAwD;AACtDL,IAAAA,MAAM,CAACO,IAAP,CAAY,cAAZ,EAA4B;AAAEF,MAAAA,UAAF;AAAcF,MAAAA;AAAd,KAA5B;AAEAF,IAAAA,oBAAoB,CAACC,OAAD,EAAUC,IAAV,EAAgBC,MAAhB,EAAwBC,UAAxB,CAApB;AACD;;AAEDhB,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIW,MAAM,IAAI,IAAd,EAAoB;AAEpBA,IAAAA,MAAM,CAACQ,EAAP,CAAU,iBAAV,EAA6BC,IAAI,IAAI;AACnCC,MAAAA,OAAO,CAACC,GAAR,CAAYF,IAAZ;AACD,KAFD;AAIA,WAAO,MAAMT,MAAM,CAACY,GAAP,CAAW,iBAAX,CAAb;AACD,GARQ,EAQN,CAACZ,MAAD,CARM,CAAT;AAUA,QAAMa,KAAK,GAAG;AACZf,IAAAA,eADY;AAEZC,IAAAA,kBAFY;AAGZO,IAAAA;AAHY,GAAd;AAMA,sBACE,oBAAC,eAAD,CAAiB,QAAjB;AAA0B,IAAA,KAAK,EAAEO,KAAjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACGhB,QADH,CADF;AAKD;AAED,eAAeL,eAAf;AAEA","sourcesContent":["import React, { useContext, useState, useEffect } from 'react'\nimport { useSocket } from './SocketProvider';\n\nimport api from \"../api\"\n\nconst ChannelsContext = React.createContext()\n\nexport function useChannels() {\n  return useContext(ChannelsContext)\n}\n\nexport function ChannelsProvider({ id, children }) {\n  const [selectedChannel, setSelectedChannel] = useState(null)\n  const socket = useSocket()\n\n  function addMessageToDatabase(channel, text, client, recipients) {\n\n    /*\n    // J'isole les données du client dans une variable pour pouvoir les modifier\n    var clientEdit = client\n    // Je boucle tous les \"channels\" du client\n    for (let i = 0; i < clientEdit.channels.length; i++) {\n      // Je teste si l'id du \"channel\" sélectionné correspond à l'id du \"channel\" passé dans la boucle\n      if (clientEdit.channels[i].id === channel.id) {\n        // J'ajoute le message aux données du client\n        clientEdit.channels[i].messages.push({\n          sender: client.id,\n          date: new Date(),\n          text: text\n        })\n        // Je mets à jour le client\n        api.updateUserById(clientEdit.id, { data: { channels: clientEdit.channels } }).then(res => {})\n      }\n    }\n\n    // Je boucle tous les destinataires\n    recipients.forEach(recipient => {\n      // J'isole les données du destinataire dans une variable pour pouvoir les modifier\n      var recipientEdit = recipient\n      // Je boucle tous les \"channels\" du destinataire\n      for (let i = 0; i < recipientEdit.channels.length; i++) {\n        // Je teste si l'id du \"channel\" sélectionné correspond à l'id du \"channel\" passé dans la boucle\n        if (recipientEdit.channels[i].id === channel.id) {\n          // J'ajoute le message aux données du destinataire\n          recipientEdit.channels[i].messages.push({\n            sender: client.id,\n            date: new Date(),\n            text: text\n          })\n          // Je mets à jour le destinataire\n          api.updateUserById(recipientEdit.id, { data: { channels: recipientEdit.channels } }).then(res => {})\n        }\n      }\n    });*/\n  }\n\n  function sendMessage(channel, text, client, recipients) {\n    socket.emit('send-message', { recipients, text })\n\n    addMessageToDatabase(channel, text, client, recipients)\n  }\n\n  useEffect(() => {\n    if (socket == null) return\n\n    socket.on('receive-message', data => {\n      console.log(data);\n    });\n    \n    return () => socket.off('receive-message')\n  }, [socket])\n\n  const value = {\n    selectedChannel,\n    setSelectedChannel,\n    sendMessage\n  }\n\n  return (\n    <ChannelsContext.Provider value={value}>\n      {children}\n    </ChannelsContext.Provider>\n  )\n}\n\nexport default ChannelsContext\n\n/*\n\nfunction arrayEquality(a, b) {\n  if (a.length !== b.length) return false\n\n  a.sort()\n  b.sort()\n\n  return a.every((element, index) => {\n    return element === b[index]\n  })\n}\n\nconst addMessageToChannel = useCallback(({ recipients, text, sender }) => {\n  setChannels(prevChannels => {\n    let madeChange = false\n    const newMessage = { sender, text }\n    const newChannels = prevChannels.map(channel => {\n      if (arrayEquality(channel.recipients, recipients)) {\n        madeChange = true\n        return {\n          ...channel,\n          messages: [...channel.messages, newMessage]\n        }\n      }\n\n      return channel\n    })\n\n    if (madeChange) {\n      return newChannels\n    } else {\n      return [\n        ...prevChannels,\n        { recipients, messages: [newMessage] }\n      ]\n    }\n  })\n}, [])*/"]},"metadata":{},"sourceType":"module"}