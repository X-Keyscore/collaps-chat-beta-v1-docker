{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\anton\\\\Desktop\\\\FInt.Tchat\\\\dev\\\\V10\\\\client\\\\src\\\\contexts\\\\ChannelsProvider.js\";\nimport React, { useContext, useState, useEffect, useRef } from 'react';\nimport { useSocket } from './SocketProvider';\nimport api from \"../api\";\nconst ChannelsContext = React.createContext();\nexport function useChannels() {\n  return useContext(ChannelsContext);\n}\nexport function ChannelsProvider({\n  id,\n  children\n}) {\n  const socket = useSocket(); // https://stackoverflow.com/questions/54824036/useeffect-hook-with-socket-io-state-is-not-persistent-in-socket-handlers\n\n  const [channels, setChannels] = useState(null);\n  const channelsRef = useRef(channels);\n  useEffect(() => {\n    channelsRef.current = channels;\n  });\n  const [messagesChannels, setMessagesChannels] = useState([]);\n  const messagesChannelsRef = useRef(messagesChannels);\n  useEffect(() => {\n    messagesChannelsRef.current = messagesChannels;\n  });\n  const [selectedChannel, setSelectedChannel] = useState(null);\n  useEffect(() => {\n    if (socket == null) return;\n\n    const addMessage = message => {\n      // J'isole les \"channels\" dans une variable\n      var allMessages = messagesChannelsRef.current;\n      const indexMessage = allMessages.findIndex(messagesChannel => messagesChannel.id === message.channelId);\n      console.log(allMessages);\n\n      if (indexMessage !== -1) {\n        console.log(\"1\");\n        const oldMsg = allMessages[indexMessage].messages;\n        allMessages[indexMessage].messages.push({\n          sender: message.sender,\n          date: message.date,\n          text: message.text\n        });\n        setMessagesChannels(msg => [...msg.slice(0, selectedChannel.key), ...msg.slice(selectedChannel.key + 1)]);\n        setMessagesChannels(msg => [...msg, {\n          id: message.channelId,\n          messages: [{\n            sender: message.sender,\n            date: message.date,\n            text: message.text\n          }]\n        }]);\n      } else {\n        console.log(\"2\");\n        setMessagesChannels(msg => [...msg, {\n          id: message.channelId,\n          messages: [{\n            sender: message.sender,\n            date: message.date,\n            text: message.text\n          }]\n        }]);\n      }\n      /*\n      // Je boucle tous les \"channels\"\n      allChannels.forEach((channel, index) => {\n        // Je vérifie si l'id est le même que celui du message\n        if (channel.id === message.channelId) {\n          // J'ajoute le message\n          setMessagesChannels([])\n          \n        }\n      })*/\n\n    }; // Si je reçoi un message je l'ajoute dans le \"channel\" qui lui correspond\n\n\n    socket.on('receive-message', addMessage);\n    return () => socket.off('receive-message', addMessage);\n  }, [socket]);\n\n  function addMessageToDatabase(channel, text, client, recipients) {\n    // J'isole les données du client dans une variable pour pouvoir les modifier\n    var clientEdit = client; // Je boucle tous les \"channels\" du client\n\n    for (let i = 0; i < clientEdit.channels.length; i++) {\n      // Je teste si l'id du \"channel\" sélectionné correspond à l'id du \"channel\" passé dans la boucle\n      if (clientEdit.channels[i].id === channel.id) {\n        // J'ajoute le message aux données du client\n        clientEdit.channels[i].messages.push({\n          sender: client.id,\n          date: new Date(),\n          text: text\n        }); // Je mets à jour le client\n\n        api.updateUserById(clientEdit.id, {\n          data: {\n            channels: clientEdit.channels\n          }\n        }).then(res => {});\n      }\n    } // Je boucle tous les destinataires\n\n\n    recipients.forEach(recipient => {\n      // J'isole les données du destinataire dans une variable pour pouvoir les modifier\n      var recipientEdit = recipient; // Je boucle tous les \"channels\" du destinataire\n\n      for (let i = 0; i < recipientEdit.channels.length; i++) {\n        // Je teste si l'id du \"channel\" sélectionné correspond à l'id du \"channel\" passé dans la boucle\n        if (recipientEdit.channels[i].id === channel.id) {\n          // J'ajoute le message aux données du destinataire\n          recipientEdit.channels[i].messages.push({\n            sender: client.id,\n            date: new Date(),\n            text: text\n          }); // Je mets à jour le destinataire\n\n          api.updateUserById(recipientEdit.id, {\n            data: {\n              channels: recipientEdit.channels\n            }\n          }).then(res => {});\n        }\n      }\n    });\n  }\n\n  function sendMessage(channel, text, client, recipients) {\n    socket.emit('send-message', {\n      channelId: channel.id,\n      recipients,\n      date: new Date(),\n      text\n    });\n    addMessageToDatabase(channel, text, client, recipients);\n  }\n\n  const value = {\n    channels,\n    setChannels,\n    messagesChannels,\n    setMessagesChannels,\n    selectedChannel,\n    setSelectedChannel,\n    sendMessage\n  };\n  return /*#__PURE__*/React.createElement(ChannelsContext.Provider, {\n    value: value,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 125,\n      columnNumber: 5\n    }\n  }, children);\n}\nexport default ChannelsContext;\n/*\n\nfunction arrayEquality(a, b) {\n  if (a.length !== b.length) return false\n\n  a.sort()\n  b.sort()\n\n  return a.every((element, index) => {\n    return element === b[index]\n  })\n}\n\nconst addMessageToChannel = useCallback(({ recipients, text, sender }) => {\n  setChannels(prevChannels => {\n    let madeChange = false\n    const newMessage = { sender, text }\n    const newChannels = prevChannels.map(channel => {\n      if (arrayEquality(channel.recipients, recipients)) {\n        madeChange = true\n        return {\n          ...channel,\n          messages: [...channel.messages, newMessage]\n        }\n      }\n\n      return channel\n    })\n\n    if (madeChange) {\n      return newChannels\n    } else {\n      return [\n        ...prevChannels,\n        { recipients, messages: [newMessage] }\n      ]\n    }\n  })\n}, [])*/","map":{"version":3,"sources":["C:/Users/anton/Desktop/FInt.Tchat/dev/V10/client/src/contexts/ChannelsProvider.js"],"names":["React","useContext","useState","useEffect","useRef","useSocket","api","ChannelsContext","createContext","useChannels","ChannelsProvider","id","children","socket","channels","setChannels","channelsRef","current","messagesChannels","setMessagesChannels","messagesChannelsRef","selectedChannel","setSelectedChannel","addMessage","message","allMessages","indexMessage","findIndex","messagesChannel","channelId","console","log","oldMsg","messages","push","sender","date","text","msg","slice","key","on","off","addMessageToDatabase","channel","client","recipients","clientEdit","i","length","Date","updateUserById","data","then","res","forEach","recipient","recipientEdit","sendMessage","emit","value"],"mappings":"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","sourcesContent":["import React, { useContext, useState, useEffect, useRef } from 'react'\nimport { useSocket } from './SocketProvider';\nimport api from \"../api\"\n\nconst ChannelsContext = React.createContext()\n\nexport function useChannels() {\n  return useContext(ChannelsContext)\n}\n\nexport function ChannelsProvider({ id, children }) {\n  const socket = useSocket()\n  // https://stackoverflow.com/questions/54824036/useeffect-hook-with-socket-io-state-is-not-persistent-in-socket-handlers\n  const [channels, setChannels] = useState(null)\n  const channelsRef = useRef(channels);\n  useEffect(() => {\n    channelsRef.current = channels;\n  });\n\n  const [messagesChannels, setMessagesChannels] = useState([])\n  const messagesChannelsRef = useRef(messagesChannels);\n  useEffect(() => {\n    messagesChannelsRef.current = messagesChannels;\n  });\n\n  const [selectedChannel, setSelectedChannel] = useState(null)\n\n  useEffect(() => {\n    if (socket == null) return\n\n    const addMessage = (message) => {\n      // J'isole les \"channels\" dans une variable\n      var allMessages = messagesChannelsRef.current\n\n      const indexMessage = allMessages.findIndex(messagesChannel => messagesChannel.id === message.channelId);\n      console.log(allMessages)\n      if (indexMessage !== -1) {\n        console.log(\"1\")\n        const oldMsg = allMessages[indexMessage].messages\n        allMessages[indexMessage].messages.push({sender: message.sender, date: message.date, text: message.text})\n        setMessagesChannels(msg => [\n          ...msg.slice(0, selectedChannel.key),\n          ...msg.slice(selectedChannel.key + 1)\n        ]);\n        setMessagesChannels(msg => [...msg, { id: message.channelId, messages: [{sender: message.sender, date: message.date, text: message.text}] }])\n      } else {\n        console.log(\"2\")\n        setMessagesChannels(msg => [...msg, { id: message.channelId, messages: [{sender: message.sender, date: message.date, text: message.text}] }])\n      }\n      /*\n      // Je boucle tous les \"channels\"\n      allChannels.forEach((channel, index) => {\n        // Je vérifie si l'id est le même que celui du message\n        if (channel.id === message.channelId) {\n          // J'ajoute le message\n          setMessagesChannels([])\n          \n        }\n      })*/\n    }\n\n    // Si je reçoi un message je l'ajoute dans le \"channel\" qui lui correspond\n    socket.on('receive-message', addMessage);\n\n    return () => socket.off('receive-message', addMessage)\n  }, [socket])\n\n  function addMessageToDatabase(channel, text, client, recipients) {\n\n    // J'isole les données du client dans une variable pour pouvoir les modifier\n    var clientEdit = client\n    // Je boucle tous les \"channels\" du client\n    for (let i = 0; i < clientEdit.channels.length; i++) {\n      // Je teste si l'id du \"channel\" sélectionné correspond à l'id du \"channel\" passé dans la boucle\n      if (clientEdit.channels[i].id === channel.id) {\n        // J'ajoute le message aux données du client\n        clientEdit.channels[i].messages.push({\n          sender: client.id,\n          date: new Date(),\n          text: text\n        })\n        // Je mets à jour le client\n        api.updateUserById(clientEdit.id, { data: { channels: clientEdit.channels } }).then(res => { })\n      }\n    }\n\n    // Je boucle tous les destinataires\n    recipients.forEach(recipient => {\n      // J'isole les données du destinataire dans une variable pour pouvoir les modifier\n      var recipientEdit = recipient\n      // Je boucle tous les \"channels\" du destinataire\n      for (let i = 0; i < recipientEdit.channels.length; i++) {\n        // Je teste si l'id du \"channel\" sélectionné correspond à l'id du \"channel\" passé dans la boucle\n        if (recipientEdit.channels[i].id === channel.id) {\n          // J'ajoute le message aux données du destinataire\n          recipientEdit.channels[i].messages.push({\n            sender: client.id,\n            date: new Date(),\n            text: text\n          })\n          // Je mets à jour le destinataire\n          api.updateUserById(recipientEdit.id, { data: { channels: recipientEdit.channels } }).then(res => { })\n        }\n      }\n    });\n  }\n\n  function sendMessage(channel, text, client, recipients) {\n    socket.emit('send-message', { channelId: channel.id, recipients, date: new Date(), text })\n\n    addMessageToDatabase(channel, text, client, recipients)\n  }\n\n  const value = {\n    channels,\n    setChannels,\n    messagesChannels,\n    setMessagesChannels,\n    selectedChannel,\n    setSelectedChannel,\n    sendMessage\n  }\n\n  return (\n    <ChannelsContext.Provider value={value}>\n      {children}\n    </ChannelsContext.Provider>\n  )\n}\n\nexport default ChannelsContext\n\n/*\n\nfunction arrayEquality(a, b) {\n  if (a.length !== b.length) return false\n\n  a.sort()\n  b.sort()\n\n  return a.every((element, index) => {\n    return element === b[index]\n  })\n}\n\nconst addMessageToChannel = useCallback(({ recipients, text, sender }) => {\n  setChannels(prevChannels => {\n    let madeChange = false\n    const newMessage = { sender, text }\n    const newChannels = prevChannels.map(channel => {\n      if (arrayEquality(channel.recipients, recipients)) {\n        madeChange = true\n        return {\n          ...channel,\n          messages: [...channel.messages, newMessage]\n        }\n      }\n\n      return channel\n    })\n\n    if (madeChange) {\n      return newChannels\n    } else {\n      return [\n        ...prevChannels,\n        { recipients, messages: [newMessage] }\n      ]\n    }\n  })\n}, [])*/"]},"metadata":{},"sourceType":"module"}