{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\anton\\\\Desktop\\\\FInt.Tchat\\\\dev\\\\V10\\\\client\\\\src\\\\contexts\\\\ChannelsProvider.js\";\nimport React, { useContext, useState, useEffect, useCallback } from 'react';\nimport { useSocket } from './SocketProvider';\nimport api from \"../api\";\nconst ChannelsContext = React.createContext();\nexport function useChannels() {\n  return useContext(ChannelsContext);\n}\nexport function ChannelsProvider({\n  id,\n  children\n}) {\n  const [selectedChannel, setSelectedChannel] = useState(null);\n  const socket = useSocket();\n\n  function addMessageToChannel(channel, client, recipients, text) {\n    // J'isole les données du client dans une variable pour pouvoir les modifier\n    var clientEdit = client; // Je boucle tous les \"channels\" du client\n\n    for (let i = 0; i < userClientEdit.channels.length; i++) {\n      // Je teste si l'id du \"channel\" sélectionné correspond à l'id du \"channel\" passé dans la boucle\n      if (userClientEdit.channels[i].recipients.id === channel.recipients.id) {\n        // Je supprime le \"channel\" dans la liste grace à sa position\n        userClientEdit.channels.splice(i, 1); // Je mets à jour le client\n\n        return api.updateUserById(userClientEdit.id, {\n          data: {\n            channels: userClientEdit.channels\n          }\n        }).then(res => {\n          /*//EN COURS// Système gestion des erreurs*/\n        });\n      }\n    }\n  }\n  /*\n  const addMessageToChannel = useCallback(({ recipients, text, sender }) => {\n    \n    setChannels(prevChannels => {\n      let madeChange = false\n      const newMessage = { sender, text }\n      const newChannels = prevChannels.map(channel => {\n        if (arrayEquality(channel.recipients, recipients)) {\n          madeChange = true\n          return {\n            ...channel,\n            messages: [...channel.messages, newMessage]\n          }\n        }\n         return channel\n      })\n       if (madeChange) {\n        return newChannels\n      } else {\n        return [\n          ...prevChannels,\n          { recipients, messages: [newMessage] }\n        ]\n      }\n    })\n  }, [])*/\n\n\n  useEffect(() => {\n    if (socket == null) return;\n    socket.on('receive-message', addMessageToChannel);\n    return () => socket.off('receive-message');\n  }, [socket, addMessageToChannel]);\n\n  function sendMessage(channel, client, recipients, text) {\n    //socket.emit('send-message', { recipients, text })\n    addMessageToChannel(channel, client, recipients, text);\n  }\n\n  const value = {\n    selectedChannel: selectedChannel,\n    setSelectedChannel,\n    sendMessage\n  };\n  return /*#__PURE__*/React.createElement(ChannelsContext.Provider, {\n    value: value,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 80,\n      columnNumber: 5\n    }\n  }, children);\n}\n\nfunction arrayEquality(a, b) {\n  if (a.length !== b.length) return false;\n  a.sort();\n  b.sort();\n  return a.every((element, index) => {\n    return element === b[index];\n  });\n}\n\nexport default ChannelsContext;","map":{"version":3,"sources":["C:/Users/anton/Desktop/FInt.Tchat/dev/V10/client/src/contexts/ChannelsProvider.js"],"names":["React","useContext","useState","useEffect","useCallback","useSocket","api","ChannelsContext","createContext","useChannels","ChannelsProvider","id","children","selectedChannel","setSelectedChannel","socket","addMessageToChannel","channel","client","recipients","text","clientEdit","i","userClientEdit","channels","length","splice","updateUserById","data","then","res","on","off","sendMessage","value","arrayEquality","a","b","sort","every","element","index"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,UAAhB,EAA4BC,QAA5B,EAAsCC,SAAtC,EAAiDC,WAAjD,QAAoE,OAApE;AACA,SAASC,SAAT,QAA0B,kBAA1B;AAEA,OAAOC,GAAP,MAAgB,QAAhB;AAEA,MAAMC,eAAe,GAAGP,KAAK,CAACQ,aAAN,EAAxB;AAEA,OAAO,SAASC,WAAT,GAAuB;AAC5B,SAAOR,UAAU,CAACM,eAAD,CAAjB;AACD;AAED,OAAO,SAASG,gBAAT,CAA0B;AAAEC,EAAAA,EAAF;AAAMC,EAAAA;AAAN,CAA1B,EAA4C;AACjD,QAAM,CAACC,eAAD,EAAkBC,kBAAlB,IAAwCZ,QAAQ,CAAC,IAAD,CAAtD;AACA,QAAMa,MAAM,GAAGV,SAAS,EAAxB;;AAEA,WAASW,mBAAT,CAA6BC,OAA7B,EAAsCC,MAAtC,EAA8CC,UAA9C,EAA0DC,IAA1D,EAAgE;AAC9D;AACA,QAAIC,UAAU,GAAGH,MAAjB,CAF8D,CAG9D;;AACA,SAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,cAAc,CAACC,QAAf,CAAwBC,MAA5C,EAAoDH,CAAC,EAArD,EAAyD;AACvD;AACA,UAAIC,cAAc,CAACC,QAAf,CAAwBF,CAAxB,EAA2BH,UAA3B,CAAsCR,EAAtC,KAA6CM,OAAO,CAACE,UAAR,CAAmBR,EAApE,EAAwE;AACtE;AACAY,QAAAA,cAAc,CAACC,QAAf,CAAwBE,MAAxB,CAA+BJ,CAA/B,EAAkC,CAAlC,EAFsE,CAGtE;;AACA,eAAOhB,GAAG,CAACqB,cAAJ,CAAmBJ,cAAc,CAACZ,EAAlC,EAAsC;AAAEiB,UAAAA,IAAI,EAAE;AAAEJ,YAAAA,QAAQ,EAAED,cAAc,CAACC;AAA3B;AAAR,SAAtC,EAAuFK,IAAvF,CAA4FC,GAAG,IAAI;AAAC;AAA6C,SAAjJ,CAAP;AACD;AACF;AACF;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA3B,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIY,MAAM,IAAI,IAAd,EAAoB;AAEpBA,IAAAA,MAAM,CAACgB,EAAP,CAAU,iBAAV,EAA6Bf,mBAA7B;AAEA,WAAO,MAAMD,MAAM,CAACiB,GAAP,CAAW,iBAAX,CAAb;AACD,GANQ,EAMN,CAACjB,MAAD,EAASC,mBAAT,CANM,CAAT;;AAQA,WAASiB,WAAT,CAAqBhB,OAArB,EAA8BC,MAA9B,EAAsCC,UAAtC,EAAkDC,IAAlD,EAAwD;AACtD;AAEAJ,IAAAA,mBAAmB,CAACC,OAAD,EAAUC,MAAV,EAAkBC,UAAlB,EAA8BC,IAA9B,CAAnB;AACD;;AAED,QAAMc,KAAK,GAAG;AACZrB,IAAAA,eAAe,EAAEA,eADL;AAEZC,IAAAA,kBAFY;AAGZmB,IAAAA;AAHY,GAAd;AAMA,sBACE,oBAAC,eAAD,CAAiB,QAAjB;AAA0B,IAAA,KAAK,EAAEC,KAAjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACGtB,QADH,CADF;AAKD;;AAED,SAASuB,aAAT,CAAuBC,CAAvB,EAA0BC,CAA1B,EAA6B;AAC3B,MAAID,CAAC,CAACX,MAAF,KAAaY,CAAC,CAACZ,MAAnB,EAA2B,OAAO,KAAP;AAE3BW,EAAAA,CAAC,CAACE,IAAF;AACAD,EAAAA,CAAC,CAACC,IAAF;AAEA,SAAOF,CAAC,CAACG,KAAF,CAAQ,CAACC,OAAD,EAAUC,KAAV,KAAoB;AACjC,WAAOD,OAAO,KAAKH,CAAC,CAACI,KAAD,CAApB;AACD,GAFM,CAAP;AAGD;;AAED,eAAelC,eAAf","sourcesContent":["import React, { useContext, useState, useEffect, useCallback } from 'react'\nimport { useSocket } from './SocketProvider';\n\nimport api from \"../api\"\n\nconst ChannelsContext = React.createContext()\n\nexport function useChannels() {\n  return useContext(ChannelsContext)\n}\n\nexport function ChannelsProvider({ id, children }) {\n  const [selectedChannel, setSelectedChannel] = useState(null)\n  const socket = useSocket()\n\n  function addMessageToChannel(channel, client, recipients, text) {\n    // J'isole les données du client dans une variable pour pouvoir les modifier\n    var clientEdit = client\n    // Je boucle tous les \"channels\" du client\n    for (let i = 0; i < userClientEdit.channels.length; i++) {\n      // Je teste si l'id du \"channel\" sélectionné correspond à l'id du \"channel\" passé dans la boucle\n      if (userClientEdit.channels[i].recipients.id === channel.recipients.id) {\n        // Je supprime le \"channel\" dans la liste grace à sa position\n        userClientEdit.channels.splice(i, 1);\n        // Je mets à jour le client\n        return api.updateUserById(userClientEdit.id, { data: { channels: userClientEdit.channels } }).then(res => {/*//EN COURS// Système gestion des erreurs*/})\n      }\n    }\n  }\n  /*\n  const addMessageToChannel = useCallback(({ recipients, text, sender }) => {\n    \n    setChannels(prevChannels => {\n      let madeChange = false\n      const newMessage = { sender, text }\n      const newChannels = prevChannels.map(channel => {\n        if (arrayEquality(channel.recipients, recipients)) {\n          madeChange = true\n          return {\n            ...channel,\n            messages: [...channel.messages, newMessage]\n          }\n        }\n\n        return channel\n      })\n\n      if (madeChange) {\n        return newChannels\n      } else {\n        return [\n          ...prevChannels,\n          { recipients, messages: [newMessage] }\n        ]\n      }\n    })\n  }, [])*/\n\n  useEffect(() => {\n    if (socket == null) return\n\n    socket.on('receive-message', addMessageToChannel)\n\n    return () => socket.off('receive-message')\n  }, [socket, addMessageToChannel])\n\n  function sendMessage(channel, client, recipients, text) {\n    //socket.emit('send-message', { recipients, text })\n\n    addMessageToChannel(channel, client, recipients, text)\n  }\n\n  const value = {\n    selectedChannel: selectedChannel,\n    setSelectedChannel,\n    sendMessage\n  }\n\n  return (\n    <ChannelsContext.Provider value={value}>\n      {children}\n    </ChannelsContext.Provider>\n  )\n}\n\nfunction arrayEquality(a, b) {\n  if (a.length !== b.length) return false\n\n  a.sort()\n  b.sort()\n\n  return a.every((element, index) => {\n    return element === b[index]\n  })\n}\n\nexport default ChannelsContext"]},"metadata":{},"sourceType":"module"}